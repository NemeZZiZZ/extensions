// @generated by Peggy 4.0.3.
//
// https://peggyjs.org/

function buildBinaryExpression(head, tail) {
	return tail.reduce((result, element) => {
		return {
			type: 'BinaryExpression',
			operator: element[1],
			left: result,
			right: element[3],
		};
	}, head);
}

function buildArgumentList(empty, first, rest) {
	return [
		...(empty ? Array.from({ length: empty.length }).fill(null) : []),
		...(first ? [first] : []),
		...(rest ? rest.map(([_, __, v]) => v) : []),
	];
}

function peg$subclass(child, parent) {
	function C() { this.constructor = child; }

	C.prototype = parent.prototype;
	child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
	const self = Error.call(this, message);

	// istanbul ignore next Check is a necessary evil to support older environments
	if (Object.setPrototypeOf) {
		Object.setPrototypeOf(self, peg$SyntaxError.prototype);
	}

	self.expected = expected;
	self.found = found;
	self.location = location;
	self.name = 'SyntaxError';
	return self;
}

peg$subclass(peg$SyntaxError, Error);

function peg$padEnd(str, targetLength, padString) {
	padString = padString || ' ';
	if (str.length > targetLength) { return str; }

	targetLength -= str.length;
	padString += padString.repeat(targetLength);
	return str + padString.slice(0, targetLength);
}

peg$SyntaxError.prototype.format = function (sources) {
	let str = `Error: ${this.message}`;

	if (this.location) {
		let src = null;
		let k;

		for (k = 0; k < sources.length; k++) {
			if (sources[k].source === this.location.source) {
				src = sources[k].text.split(/\r\n|\n|\r/g);
				break;
			}
		}

		const s = this.location.start;

		const offset_s = (this.location.source && (typeof this.location.source.offset === 'function'))
			? this.location.source.offset(s)
			: s;

		const loc = `${this.location.source}:${offset_s.line}:${offset_s.column}`;

		if (src) {
			const e = this.location.end;
			const filler = peg$padEnd('', offset_s.line.toString().length, ' ');
			const line = src[s.line - 1];
			const last = s.line === e.line ? e.column : line.length + 1;
			const hatLen = (last - s.column) || 1;

			str += `\n --> ${loc}\n${
				filler} |\n${
				offset_s.line} | ${line}\n${
				filler} | ${peg$padEnd('', s.column - 1, ' ')
			}${peg$padEnd('', hatLen, '^')}`;
		}
		else {
			str += `\n at ${loc}`;
		}
	}

	return str;
};

peg$SyntaxError.buildMessage = function (expected, found) {
	const DESCRIBE_EXPECTATION_FNS = {
		literal(expectation) {
			return `"${literalEscape(expectation.text)}"`;
		},

		class(expectation) {
			const escapedParts = expectation.parts.map((part) => {
				return Array.isArray(part)
					? `${classEscape(part[0])}-${classEscape(part[1])}`
					: classEscape(part);
			});

			return `[${expectation.inverted ? '^' : ''}${escapedParts.join('')}]`;
		},

		any() {
			return 'any character';
		},

		end() {
			return 'end of input';
		},

		other(expectation) {
			return expectation.description;
		},
	};

	function hex(ch) {
		return ch.charCodeAt(0).toString(16).toUpperCase();
	}

	function literalEscape(s) {
		return s
			.replace(/\\/g, '\\\\')
			.replace(/"/g, '\\"')
			.replace(/\0/g, '\\0')
			.replace(/\t/g, '\\t')
			.replace(/\n/g, '\\n')
			.replace(/\r/g, '\\r')
			.replace(/[\x00-\x0F]/g, (ch) => { return `\\x0${hex(ch)}`; })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => { return `\\x${hex(ch)}`; });
	}

	function classEscape(s) {
		return s
			.replace(/\\/g, '\\\\')
			.replace(/\]/g, '\\]')
			.replace(/\^/g, '\\^')
			.replace(/-/g, '\\-')
			.replace(/\0/g, '\\0')
			.replace(/\t/g, '\\t')
			.replace(/\n/g, '\\n')
			.replace(/\r/g, '\\r')
			.replace(/[\x00-\x0F]/g, (ch) => { return `\\x0${hex(ch)}`; })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => { return `\\x${hex(ch)}`; });
	}

	function describeExpectation(expectation) {
		return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	}

	function describeExpected(expected) {
		const descriptions = expected.map(describeExpectation);
		let i, j;

		descriptions.sort();

		if (descriptions.length > 0) {
			for (i = 1, j = 1; i < descriptions.length; i++) {
				if (descriptions[i - 1] !== descriptions[i]) {
					descriptions[j] = descriptions[i];
					j++;
				}
			}

			descriptions.length = j;
		}

		switch (descriptions.length) {
			case 1:
				return descriptions[0];

			case 2:
				return `${descriptions[0]} or ${descriptions[1]}`;

			default:
				return `${descriptions.slice(0, -1).join(', ')
				}, or ${
					descriptions[descriptions.length - 1]}`;
		}
	}

	function describeFound(found) {
		return found ? `"${literalEscape(found)}"` : 'end of input';
	}

	return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
	options = options !== undefined ? options : {};

	const peg$FAILED = {};
	const peg$source = options.grammarSource;

	const peg$startRuleFunctions = { Formula: peg$parseFormula };
	let peg$startRuleFunction = peg$parseFormula;

	const peg$c0 = '-';
	const peg$c1 = '*';
	const peg$c2 = '=';
	const peg$c3 = '/';
	const peg$c4 = '%';
	const peg$c5 = '+';
	const peg$c6 = '<=';
	const peg$c7 = '>=';
	const peg$c8 = '<';
	const peg$c9 = '>';
	const peg$c10 = '==';
	const peg$c11 = '!=';
	const peg$c12 = '(';
	const peg$c13 = ')';
	const peg$c14 = ',';
	const peg$c15 = '{{';
	const peg$c16 = '}}';
	const peg$c17 = '...{{';
	const peg$c18 = '.';
	const peg$c19 = 'true';
	const peg$c20 = 'false';
	const peg$c21 = '0';
	const peg$c22 = '"';
	const peg$c23 = '\'';
	const peg$c24 = '\\"';
	const peg$c25 = '\\\'';

	const peg$r0 = /^[+=]/;
	const peg$r1 = /^[\-=]/;
	const peg$r2 = /^[A-Z]/;
	const peg$r3 = /^[A-Z0-9]/;
	const peg$r4 = /^[a-z_\-]/i;
	const peg$r5 = /^[\w\-]/;
	const peg$r6 = /^\d/;
	const peg$r7 = /^[1-9]/;
	const peg$r8 = /^[ \t\n\r]/;

	const peg$e0 = peg$literalExpectation('-', false);
	const peg$e1 = peg$literalExpectation('*', false);
	const peg$e2 = peg$literalExpectation('=', false);
	const peg$e3 = peg$literalExpectation('/', false);
	const peg$e4 = peg$literalExpectation('%', false);
	const peg$e5 = peg$literalExpectation('+', false);
	const peg$e6 = peg$classExpectation(['+', '='], false, false);
	const peg$e7 = peg$classExpectation(['-', '='], false, false);
	const peg$e8 = peg$literalExpectation('<=', false);
	const peg$e9 = peg$literalExpectation('>=', false);
	const peg$e10 = peg$literalExpectation('<', false);
	const peg$e11 = peg$literalExpectation('>', false);
	const peg$e12 = peg$literalExpectation('==', false);
	const peg$e13 = peg$literalExpectation('!=', false);
	const peg$e14 = peg$otherExpectation('parenthesis');
	const peg$e15 = peg$literalExpectation('(', false);
	const peg$e16 = peg$literalExpectation(')', false);
	const peg$e17 = peg$otherExpectation('constant or field');
	const peg$e18 = peg$literalExpectation(',', false);
	const peg$e19 = peg$classExpectation([['A', 'Z']], false, false);
	const peg$e20 = peg$classExpectation([['A', 'Z'], ['0', '9']], false, false);
	const peg$e21 = peg$otherExpectation('field reference');
	const peg$e22 = peg$literalExpectation('{{', false);
	const peg$e23 = peg$literalExpectation('}}', false);
	const peg$e24 = peg$otherExpectation('spread field reference');
	const peg$e25 = peg$literalExpectation('...{{', false);
	const peg$e26 = peg$otherExpectation('field name');
	const peg$e27 = peg$otherExpectation('simple field name');
	const peg$e28 = peg$classExpectation([['a', 'z'], ['A', 'Z'], '_', '-'], false, false);
	const peg$e29 = peg$classExpectation([['a', 'z'], ['A', 'Z'], ['0', '9'], '_', '-'], false, false);
	const peg$e30 = peg$otherExpectation('relational field name');
	const peg$e31 = peg$literalExpectation('.', false);
	const peg$e32 = peg$otherExpectation('boolean');
	const peg$e33 = peg$literalExpectation('true', true);
	const peg$e34 = peg$literalExpectation('false', true);
	const peg$e35 = peg$otherExpectation('number');
	const peg$e36 = peg$literalExpectation('0', false);
	const peg$e37 = peg$classExpectation([['0', '9']], false, false);
	const peg$e38 = peg$classExpectation([['1', '9']], false, false);
	const peg$e39 = peg$otherExpectation('integer');
	const peg$e40 = peg$otherExpectation('string');
	const peg$e41 = peg$literalExpectation('"', false);
	const peg$e42 = peg$literalExpectation('\'', false);
	const peg$e43 = peg$literalExpectation('\\"', false);
	const peg$e44 = peg$anyExpectation();
	const peg$e45 = peg$literalExpectation('\\\'', false);
	const peg$e46 = peg$otherExpectation('whitespace');
	const peg$e47 = peg$classExpectation([' ', '\t', '\n', '\r'], false, false);

	const peg$f0 = function (operator, value) { return operator && operator === '-' ? { type: 'UnaryExpression', operator, value } : value; };

	const peg$f1 = function (head, tail) { return buildBinaryExpression(head, tail); };

	const peg$f2 = function (head, tail) { return buildBinaryExpression(head, tail); };

	const peg$f3 = function (head, tail) { return buildBinaryExpression(head, tail); };

	const peg$f4 = function (head, tail) { return buildBinaryExpression(head, tail); };

	const peg$f5 = function (exp) { return exp; };

	const peg$f6 = function (name, args) { return { type: 'Function', name, arguments: args }; };

	const peg$f7 = function (empty, first, rest) { return buildArgumentList(empty, first, rest); };

	const peg$f8 = function () { return text(); };

	const peg$f9 = function (field) { return { type: 'Reference', field }; };

	const peg$f10 = function (field) { return { type: 'Reference', spread: true, field }; };

	const peg$f11 = function () { return text(); };

	const peg$f12 = function (head, tail) { return [head, ...tail.map(([_, k]) => k)].join('.'); };

	const peg$f13 = function () { return { type: 'Literal', value: text().toLowerCase() === 'true' }; };

	const peg$f14 = function () {
		return { type: 'Literal', value: Number.parseFloat(text()) };
	};

	const peg$f15 = function () {
		return { type: 'Literal', value: Number.parseFloat(text()) };
	};

	const peg$f16 = function () {
		return { type: 'Literal', value: Number.parseFloat(text()) };
	};

	const peg$f17 = function () { return { type: 'Literal', value: Number.parseInt(text(), 10) }; };

	const peg$f18 = function (chars) {
		return { type: 'Literal', value: chars.join('') };
	};

	const peg$f19 = function (chars) {
		return { type: 'Literal', value: chars.join('') };
	};

	const peg$f20 = function () { return text(); };

	const peg$f21 = function () { return '"'; };

	const peg$f22 = function () { return text(); };

	const peg$f23 = function () { return '\''; };

	let peg$currPos = options.peg$currPos | 0;
	let peg$savedPos = peg$currPos;
	const peg$posDetailsCache = [{ line: 1, column: 1 }];
	let peg$maxFailPos = peg$currPos;
	let peg$maxFailExpected = options.peg$maxFailExpected || [];
	let peg$silentFails = options.peg$silentFails | 0;

	let peg$result;

	if (options.startRule) {
		if (!(options.startRule in peg$startRuleFunctions)) {
			throw new Error(`Can't start parsing from rule "${options.startRule}".`);
		}

		peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}

	function text() {
		return input.substring(peg$savedPos, peg$currPos);
	}

	function offset() {
		return peg$savedPos;
	}

	function range() {
		return {
			source: peg$source,
			start: peg$savedPos,
			end: peg$currPos,
		};
	}

	function location() {
		return peg$computeLocation(peg$savedPos, peg$currPos);
	}

	function expected(description, location) {
		location = location !== undefined
			? location
			: peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildStructuredError(
			[peg$otherExpectation(description)],
			input.substring(peg$savedPos, peg$currPos),
			location,
		);
	}

	function error(message, location) {
		location = location !== undefined
			? location
			: peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildSimpleError(message, location);
	}

	function peg$literalExpectation(text, ignoreCase) {
		return { type: 'literal', text, ignoreCase };
	}

	function peg$classExpectation(parts, inverted, ignoreCase) {
		return { type: 'class', parts, inverted, ignoreCase };
	}

	function peg$anyExpectation() {
		return { type: 'any' };
	}

	function peg$endExpectation() {
		return { type: 'end' };
	}

	function peg$otherExpectation(description) {
		return { type: 'other', description };
	}

	function peg$computePosDetails(pos) {
		let details = peg$posDetailsCache[pos];
		let p;

		if (details) {
			return details;
		}
		else {
			if (pos >= peg$posDetailsCache.length) {
				p = peg$posDetailsCache.length - 1;
			}
			else {
				p = pos;
				while (!peg$posDetailsCache[--p]) {}
			}

			details = peg$posDetailsCache[p];

			details = {
				line: details.line,
				column: details.column,
			};

			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				}
				else {
					details.column++;
				}

				p++;
			}

			peg$posDetailsCache[pos] = details;

			return details;
		}
	}

	function peg$computeLocation(startPos, endPos, offset) {
		const startPosDetails = peg$computePosDetails(startPos);
		const endPosDetails = peg$computePosDetails(endPos);

		const res = {
			source: peg$source,
			start: {
				offset: startPos,
				line: startPosDetails.line,
				column: startPosDetails.column,
			},
			end: {
				offset: endPos,
				line: endPosDetails.line,
				column: endPosDetails.column,
			},
		};

		if (offset && peg$source && (typeof peg$source.offset === 'function')) {
			res.start = peg$source.offset(res.start);
			res.end = peg$source.offset(res.end);
		}

		return res;
	}

	function peg$fail(expected) {
		if (peg$currPos < peg$maxFailPos) { return; }

		if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		}

		peg$maxFailExpected.push(expected);
	}

	function peg$buildSimpleError(message, location) {
		return new peg$SyntaxError(message, null, null, location);
	}

	function peg$buildStructuredError(expected, found, location) {
		return new peg$SyntaxError(
			peg$SyntaxError.buildMessage(expected, found),
			expected,
			found,
			location,
		);
	}

	function peg$parseFormula() {
		let s0;

		s0 = peg$parseParen();

		if (s0 === peg$FAILED) {
			s0 = peg$parseConstant();

			if (s0 === peg$FAILED) {
				s0 = peg$parseFunctionCall();
			}
		}

		return s0;
	}

	function peg$parseUnaryExpression() {
		let s0, s1, s2;

		s0 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 45) {
			s1 = peg$c0;
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e0); }
		}

		if (s1 === peg$FAILED) {
			s1 = null;
		}

		s2 = peg$parseFormula();

		if (s2 !== peg$FAILED) {
			peg$savedPos = s0;
			s0 = peg$f0(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseMultiplicativeExpression() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		s0 = peg$currPos;
		s1 = peg$parseUnaryExpression();

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			s4 = peg$parse_();
			s5 = peg$parseMultiplicativeOperator();

			if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				s7 = peg$parseUnaryExpression();

				if (s7 !== peg$FAILED) {
					s4 = [s4, s5, s6, s7];
					s3 = s4;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;
				s4 = peg$parse_();
				s5 = peg$parseMultiplicativeOperator();

				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$parseUnaryExpression();

					if (s7 !== peg$FAILED) {
						s4 = [s4, s5, s6, s7];
						s3 = s4;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}

			peg$savedPos = s0;
			s0 = peg$f1(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseMultiplicativeOperator() {
		let s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		s1 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 42) {
			s2 = peg$c1;
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e1); }
		}

		if (s2 !== peg$FAILED) {
			s3 = peg$currPos;
			peg$silentFails++;

			if (input.charCodeAt(peg$currPos) === 61) {
				s4 = peg$c2;
				peg$currPos++;
			}
			else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e2); }
			}

			peg$silentFails--;

			if (s4 === peg$FAILED) {
				s3 = undefined;
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			if (s3 !== peg$FAILED) {
				s2 = [s2, s3];
				s1 = s2;
			}
			else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}

		if (s1 !== peg$FAILED) {
			s0 = input.substring(s0, peg$currPos);
		}
		else {
			s0 = s1;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 47) {
				s2 = peg$c3;
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e3); }
			}

			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				peg$silentFails++;

				if (input.charCodeAt(peg$currPos) === 61) {
					s4 = peg$c2;
					peg$currPos++;
				}
				else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e2); }
				}

				peg$silentFails--;

				if (s4 === peg$FAILED) {
					s3 = undefined;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}

				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				}
				else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				s0 = input.substring(s0, peg$currPos);
			}
			else {
				s0 = s1;
			}

			if (s0 === peg$FAILED) {
				s0 = peg$currPos;
				s1 = peg$currPos;

				if (input.charCodeAt(peg$currPos) === 37) {
					s2 = peg$c4;
					peg$currPos++;
				}
				else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e4); }
				}

				if (s2 !== peg$FAILED) {
					s3 = peg$currPos;
					peg$silentFails++;

					if (input.charCodeAt(peg$currPos) === 61) {
						s4 = peg$c2;
						peg$currPos++;
					}
					else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e2); }
					}

					peg$silentFails--;

					if (s4 === peg$FAILED) {
						s3 = undefined;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}

					if (s3 !== peg$FAILED) {
						s2 = [s2, s3];
						s1 = s2;
					}
					else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}

				if (s1 !== peg$FAILED) {
					s0 = input.substring(s0, peg$currPos);
				}
				else {
					s0 = s1;
				}
			}
		}

		return s0;
	}

	function peg$parseAdditiveExpression() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		s0 = peg$currPos;
		s1 = peg$parseMultiplicativeExpression();

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			s4 = peg$parse_();
			s5 = peg$parseAdditiveOperator();

			if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				s7 = peg$parseMultiplicativeExpression();

				if (s7 !== peg$FAILED) {
					s4 = [s4, s5, s6, s7];
					s3 = s4;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;
				s4 = peg$parse_();
				s5 = peg$parseAdditiveOperator();

				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$parseMultiplicativeExpression();

					if (s7 !== peg$FAILED) {
						s4 = [s4, s5, s6, s7];
						s3 = s4;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}

			peg$savedPos = s0;
			s0 = peg$f2(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseAdditiveOperator() {
		let s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		s1 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 43) {
			s2 = peg$c5;
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e5); }
		}

		if (s2 !== peg$FAILED) {
			s3 = peg$currPos;
			peg$silentFails++;
			s4 = input.charAt(peg$currPos);

			if (peg$r0.test(s4)) {
				peg$currPos++;
			}
			else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e6); }
			}

			peg$silentFails--;

			if (s4 === peg$FAILED) {
				s3 = undefined;
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			if (s3 !== peg$FAILED) {
				s2 = [s2, s3];
				s1 = s2;
			}
			else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}

		if (s1 !== peg$FAILED) {
			s0 = input.substring(s0, peg$currPos);
		}
		else {
			s0 = s1;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 45) {
				s2 = peg$c0;
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e0); }
			}

			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				peg$silentFails++;
				s4 = input.charAt(peg$currPos);

				if (peg$r1.test(s4)) {
					peg$currPos++;
				}
				else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e7); }
				}

				peg$silentFails--;

				if (s4 === peg$FAILED) {
					s3 = undefined;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}

				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				}
				else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				s0 = input.substring(s0, peg$currPos);
			}
			else {
				s0 = s1;
			}
		}

		return s0;
	}

	function peg$parseRelationalExpression() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		s0 = peg$currPos;
		s1 = peg$parseAdditiveExpression();

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			s4 = peg$parse_();
			s5 = peg$parseRelationalOperator();

			if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				s7 = peg$parseAdditiveExpression();

				if (s7 !== peg$FAILED) {
					s4 = [s4, s5, s6, s7];
					s3 = s4;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;
				s4 = peg$parse_();
				s5 = peg$parseRelationalOperator();

				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$parseAdditiveExpression();

					if (s7 !== peg$FAILED) {
						s4 = [s4, s5, s6, s7];
						s3 = s4;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}

			peg$savedPos = s0;
			s0 = peg$f3(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseRelationalOperator() {
		let s0, s1, s2, s3, s4;

		if (input.substr(peg$currPos, 2) === peg$c6) {
			s0 = peg$c6;
			peg$currPos += 2;
		}
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e8); }
		}

		if (s0 === peg$FAILED) {
			if (input.substr(peg$currPos, 2) === peg$c7) {
				s0 = peg$c7;
				peg$currPos += 2;
			}
			else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e9); }
			}

			if (s0 === peg$FAILED) {
				s0 = peg$currPos;
				s1 = peg$currPos;

				if (input.charCodeAt(peg$currPos) === 60) {
					s2 = peg$c8;
					peg$currPos++;
				}
				else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e10); }
				}

				if (s2 !== peg$FAILED) {
					s3 = peg$currPos;
					peg$silentFails++;

					if (input.charCodeAt(peg$currPos) === 60) {
						s4 = peg$c8;
						peg$currPos++;
					}
					else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e10); }
					}

					peg$silentFails--;

					if (s4 === peg$FAILED) {
						s3 = undefined;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}

					if (s3 !== peg$FAILED) {
						s2 = [s2, s3];
						s1 = s2;
					}
					else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}

				if (s1 !== peg$FAILED) {
					s0 = input.substring(s0, peg$currPos);
				}
				else {
					s0 = s1;
				}

				if (s0 === peg$FAILED) {
					s0 = peg$currPos;
					s1 = peg$currPos;

					if (input.charCodeAt(peg$currPos) === 62) {
						s2 = peg$c9;
						peg$currPos++;
					}
					else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e11); }
					}

					if (s2 !== peg$FAILED) {
						s3 = peg$currPos;
						peg$silentFails++;

						if (input.charCodeAt(peg$currPos) === 62) {
							s4 = peg$c9;
							peg$currPos++;
						}
						else {
							s4 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e11); }
						}

						peg$silentFails--;

						if (s4 === peg$FAILED) {
							s3 = undefined;
						}
						else {
							peg$currPos = s3;
							s3 = peg$FAILED;
						}

						if (s3 !== peg$FAILED) {
							s2 = [s2, s3];
							s1 = s2;
						}
						else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
					}
					else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}

					if (s1 !== peg$FAILED) {
						s0 = input.substring(s0, peg$currPos);
					}
					else {
						s0 = s1;
					}
				}
			}
		}

		return s0;
	}

	function peg$parseEqualityExpression() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		s0 = peg$currPos;
		s1 = peg$parseRelationalExpression();

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			s4 = peg$parse_();
			s5 = peg$parseEqualityOperator();

			if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				s7 = peg$parseRelationalExpression();

				if (s7 !== peg$FAILED) {
					s4 = [s4, s5, s6, s7];
					s3 = s4;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;
				s4 = peg$parse_();
				s5 = peg$parseEqualityOperator();

				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$parseRelationalExpression();

					if (s7 !== peg$FAILED) {
						s4 = [s4, s5, s6, s7];
						s3 = s4;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}

			peg$savedPos = s0;
			s0 = peg$f4(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseEqualityOperator() {
		let s0;

		if (input.substr(peg$currPos, 2) === peg$c10) {
			s0 = peg$c10;
			peg$currPos += 2;
		}
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e12); }
		}

		if (s0 === peg$FAILED) {
			if (input.substr(peg$currPos, 2) === peg$c11) {
				s0 = peg$c11;
				peg$currPos += 2;
			}
			else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e13); }
			}
		}

		return s0;
	}

	function peg$parseParen() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 40) {
			s1 = peg$c12;
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e15); }
		}

		if (s1 !== peg$FAILED) {
			s2 = peg$parseEqualityExpression();

			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 41) {
					s3 = peg$c13;
					peg$currPos++;
				}
				else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e16); }
				}

				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f5(s2);
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e14); }
		}

		return s0;
	}

	function peg$parseConstant() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseNumericLiteral();

		if (s0 === peg$FAILED) {
			s0 = peg$parseStringLiteral();

			if (s0 === peg$FAILED) {
				s0 = peg$parseBooleanLiteral();

				if (s0 === peg$FAILED) {
					s0 = peg$parseFieldReference();
				}
			}
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e17); }
		}

		return s0;
	}

	function peg$parseFunctionCall() {
		let s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		s1 = peg$parseFunctionName();

		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 40) {
				s2 = peg$c12;
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e15); }
			}

			if (s2 !== peg$FAILED) {
				s3 = peg$parseArguments();

				if (input.charCodeAt(peg$currPos) === 41) {
					s4 = peg$c13;
					peg$currPos++;
				}
				else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e16); }
				}

				if (s4 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f6(s1, s3);
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseArguments() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		s0 = peg$currPos;
		s1 = [];

		if (input.charCodeAt(peg$currPos) === 44) {
			s2 = peg$c14;
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e18); }
		}

		while (s2 !== peg$FAILED) {
			s1.push(s2);

			if (input.charCodeAt(peg$currPos) === 44) {
				s2 = peg$c14;
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e18); }
			}
		}

		s2 = peg$parseEqualityExpression();

		if (s2 === peg$FAILED) {
			s2 = null;
		}

		s3 = [];
		s4 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 44) {
			s5 = peg$c14;
			peg$currPos++;
		}
		else {
			s5 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e18); }
		}

		if (s5 !== peg$FAILED) {
			s6 = peg$parse_();
			s7 = peg$parseEqualityExpression();

			if (s7 !== peg$FAILED) {
				s5 = [s5, s6, s7];
				s4 = s5;
			}
			else {
				peg$currPos = s4;
				s4 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s4;
			s4 = peg$FAILED;
		}

		while (s4 !== peg$FAILED) {
			s3.push(s4);
			s4 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 44) {
				s5 = peg$c14;
				peg$currPos++;
			}
			else {
				s5 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e18); }
			}

			if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				s7 = peg$parseEqualityExpression();

				if (s7 !== peg$FAILED) {
					s5 = [s5, s6, s7];
					s4 = s5;
				}
				else {
					peg$currPos = s4;
					s4 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s4;
				s4 = peg$FAILED;
			}
		}

		peg$savedPos = s0;
		s0 = peg$f7(s1, s2, s3);

		return s0;
	}

	function peg$parseFunctionName() {
		let s0, s1, s2, s3;

		s0 = peg$currPos;
		s1 = input.charAt(peg$currPos);

		if (peg$r2.test(s1)) {
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e19); }
		}

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = input.charAt(peg$currPos);

			if (peg$r3.test(s3)) {
				peg$currPos++;
			}
			else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e20); }
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = input.charAt(peg$currPos);

				if (peg$r3.test(s3)) {
					peg$currPos++;
				}
				else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e20); }
				}
			}

			peg$savedPos = s0;
			s0 = peg$f8();
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseFieldReference() {
		let s0, s1, s2, s3, s4, s5;

		peg$silentFails++;
		s0 = peg$currPos;

		if (input.substr(peg$currPos, 2) === peg$c15) {
			s1 = peg$c15;
			peg$currPos += 2;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e22); }
		}

		if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			s3 = peg$parseFieldKey();

			if (s3 !== peg$FAILED) {
				s4 = peg$parse_();

				if (input.substr(peg$currPos, 2) === peg$c16) {
					s5 = peg$c16;
					peg$currPos += 2;
				}
				else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e23); }
				}

				if (s5 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f9(s3);
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e21); }
		}

		return s0;
	}

	function peg$parseSpreadFieldReference() {
		let s0, s1, s2, s3, s4, s5;

		peg$silentFails++;
		s0 = peg$currPos;

		if (input.substr(peg$currPos, 5) === peg$c17) {
			s1 = peg$c17;
			peg$currPos += 5;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e25); }
		}

		if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			s3 = peg$parseFieldKey();

			if (s3 !== peg$FAILED) {
				s4 = peg$parse_();

				if (input.substr(peg$currPos, 2) === peg$c16) {
					s5 = peg$c16;
					peg$currPos += 2;
				}
				else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e23); }
				}

				if (s5 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f10(s3);
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e24); }
		}

		return s0;
	}

	function peg$parseFieldKey() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseRelationFieldKey();
		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e26); }
		}

		return s0;
	}

	function peg$parseSimpleFieldKey() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = input.charAt(peg$currPos);

		if (peg$r4.test(s1)) {
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e28); }
		}

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = input.charAt(peg$currPos);

			if (peg$r5.test(s3)) {
				peg$currPos++;
			}
			else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e29); }
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = input.charAt(peg$currPos);

				if (peg$r5.test(s3)) {
					peg$currPos++;
				}
				else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e29); }
				}
			}

			peg$savedPos = s0;
			s0 = peg$f11();
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e27); }
		}

		return s0;
	}

	function peg$parseRelationFieldKey() {
		let s0, s1, s2, s3, s4, s5;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseSimpleFieldKey();

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 46) {
				s4 = peg$c18;
				peg$currPos++;
			}
			else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e31); }
			}

			if (s4 !== peg$FAILED) {
				s5 = peg$parseSimpleFieldKey();

				if (s5 !== peg$FAILED) {
					s4 = [s4, s5];
					s3 = s4;
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;

				if (input.charCodeAt(peg$currPos) === 46) {
					s4 = peg$c18;
					peg$currPos++;
				}
				else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e31); }
				}

				if (s4 !== peg$FAILED) {
					s5 = peg$parseSimpleFieldKey();

					if (s5 !== peg$FAILED) {
						s4 = [s4, s5];
						s3 = s4;
					}
					else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}

			peg$savedPos = s0;
			s0 = peg$f12(s1, s2);
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e30); }
		}

		return s0;
	}

	function peg$parseBooleanLiteral() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = input.substr(peg$currPos, 4);

		if (s1.toLowerCase() === peg$c19) {
			peg$currPos += 4;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e33); }
		}

		if (s1 === peg$FAILED) {
			s1 = input.substr(peg$currPos, 5);

			if (s1.toLowerCase() === peg$c20) {
				peg$currPos += 5;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e34); }
			}
		}

		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$f13();
		}

		s0 = s1;
		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e32); }
		}

		return s0;
	}

	function peg$parseNumericLiteral() {
		let s0, s1, s2, s3, s4;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseDecimalIntegerLiteral();

		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c18;
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e31); }
			}

			if (s2 !== peg$FAILED) {
				s3 = [];
				s4 = peg$parseDecimalDigit();

				while (s4 !== peg$FAILED) {
					s3.push(s4);
					s4 = peg$parseDecimalDigit();
				}

				peg$savedPos = s0;
				s0 = peg$f14();
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 46) {
				s1 = peg$c18;
				peg$currPos++;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e31); }
			}

			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parseDecimalDigit();

				if (s3 !== peg$FAILED) {
					while (s3 !== peg$FAILED) {
						s2.push(s3);
						s3 = peg$parseDecimalDigit();
					}
				}
				else {
					s2 = peg$FAILED;
				}

				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f15();
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			if (s0 === peg$FAILED) {
				s0 = peg$currPos;
				s1 = peg$parseDecimalIntegerLiteral();

				if (s1 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$f16();
				}

				s0 = s1;
			}
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e35); }
		}

		return s0;
	}

	function peg$parseDecimalIntegerLiteral() {
		let s0, s1, s2, s3;

		if (input.charCodeAt(peg$currPos) === 48) {
			s0 = peg$c21;
			peg$currPos++;
		}
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e36); }
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parseNonZeroDigit();

			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parseDecimalDigit();

				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parseDecimalDigit();
				}

				s1 = [s1, s2];
				s0 = s1;
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}

		return s0;
	}

	function peg$parseDecimalDigit() {
		let s0;

		s0 = input.charAt(peg$currPos);

		if (peg$r6.test(s0)) {
			peg$currPos++;
		}
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e37); }
		}

		return s0;
	}

	function peg$parseNonZeroDigit() {
		let s0;

		s0 = input.charAt(peg$currPos);

		if (peg$r7.test(s0)) {
			peg$currPos++;
		}
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e38); }
		}

		return s0;
	}

	function peg$parseIntegerLiteral() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		s2 = input.charAt(peg$currPos);

		if (peg$r6.test(s2)) {
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e37); }
		}

		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				s2 = input.charAt(peg$currPos);

				if (peg$r6.test(s2)) {
					peg$currPos++;
				}
				else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e37); }
				}
			}
		}
		else {
			s1 = peg$FAILED;
		}

		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$f17();
		}

		s0 = s1;
		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e39); }
		}

		return s0;
	}

	function peg$parseStringLiteral() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;

		if (input.charCodeAt(peg$currPos) === 34) {
			s1 = peg$c22;
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e41); }
		}

		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseDoubleStringCharacter();

			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseDoubleStringCharacter();
			}

			if (input.charCodeAt(peg$currPos) === 34) {
				s3 = peg$c22;
				peg$currPos++;
			}
			else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e41); }
			}

			if (s3 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f18(s2);
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;

			if (input.charCodeAt(peg$currPos) === 39) {
				s1 = peg$c23;
				peg$currPos++;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e42); }
			}

			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parseSingleStringCharacter();

				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parseSingleStringCharacter();
				}

				if (input.charCodeAt(peg$currPos) === 39) {
					s3 = peg$c23;
					peg$currPos++;
				}
				else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e42); }
				}

				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f19(s2);
				}
				else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}

		peg$silentFails--;

		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e40); }
		}

		return s0;
	}

	function peg$parseDoubleStringCharacter() {
		let s0, s1, s2;

		s0 = peg$currPos;
		s1 = peg$currPos;
		peg$silentFails++;

		if (input.charCodeAt(peg$currPos) === 34) {
			s2 = peg$c22;
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e41); }
		}

		if (s2 === peg$FAILED) {
			if (input.substr(peg$currPos, 2) === peg$c24) {
				s2 = peg$c24;
				peg$currPos += 2;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e43); }
			}
		}

		peg$silentFails--;

		if (s2 === peg$FAILED) {
			s1 = undefined;
		}
		else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}

		if (s1 !== peg$FAILED) {
			if (input.length > peg$currPos) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e44); }
			}

			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f20();
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;

			if (input.substr(peg$currPos, 2) === peg$c24) {
				s1 = peg$c24;
				peg$currPos += 2;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e43); }
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$f21();
			}

			s0 = s1;
		}

		return s0;
	}

	function peg$parseSingleStringCharacter() {
		let s0, s1, s2;

		s0 = peg$currPos;
		s1 = peg$currPos;
		peg$silentFails++;

		if (input.charCodeAt(peg$currPos) === 39) {
			s2 = peg$c23;
			peg$currPos++;
		}
		else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e42); }
		}

		if (s2 === peg$FAILED) {
			if (input.substr(peg$currPos, 2) === peg$c25) {
				s2 = peg$c25;
				peg$currPos += 2;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e45); }
			}
		}

		peg$silentFails--;

		if (s2 === peg$FAILED) {
			s1 = undefined;
		}
		else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}

		if (s1 !== peg$FAILED) {
			if (input.length > peg$currPos) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			}
			else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e44); }
			}

			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f22();
			}
			else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		if (s0 === peg$FAILED) {
			s0 = peg$currPos;

			if (input.substr(peg$currPos, 2) === peg$c25) {
				s1 = peg$c25;
				peg$currPos += 2;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e45); }
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$f23();
			}

			s0 = s1;
		}

		return s0;
	}

	function peg$parse_() {
		let s0, s1;

		peg$silentFails++;
		s0 = [];
		s1 = input.charAt(peg$currPos);

		if (peg$r8.test(s1)) {
			peg$currPos++;
		}
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e47); }
		}

		while (s1 !== peg$FAILED) {
			s0.push(s1);
			s1 = input.charAt(peg$currPos);

			if (peg$r8.test(s1)) {
				peg$currPos++;
			}
			else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e47); }
			}
		}

		peg$silentFails--;
		s1 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$e46); }

		return s0;
	}

	peg$result = peg$startRuleFunction();

	if (options.peg$library) {
		return /** @type {any} */ ({
			peg$result,
			peg$currPos,
			peg$FAILED,
			peg$maxFailExpected,
			peg$maxFailPos,
		});
	}

	if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		return peg$result;
	}
	else {
		if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail(peg$endExpectation());
		}

		throw peg$buildStructuredError(
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
				? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
				: peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
		);
	}
}

const peg$allowedStartRules = [
	'Formula',
];

export {
	peg$parse as parse,
	peg$allowedStartRules as StartRules,
	peg$SyntaxError as SyntaxError,
};
